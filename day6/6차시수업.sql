

--JOIN
--
SELECT * FROM TBL_TEST_ORDER;
SELECT * FROM TBL_TEST_GOODS;
SELECT * FROM TBL_TEST_CUSTOMER;

--에이콘 쇼핑몰 정보

--EQUAL INNER 조인
SELECT *
FROM TBL_TEST_ORDER O
JOIN TBL_TEST_CUSTOMER C
ON O.ID = C.ID;

--고객별 판매수량 합계
SELECT C.NAME, O.SALE_CNT
FROM TBL_TEST_ORDER O
JOIN TBL_TEST_CUSTOMER C
ON O.ID = C.ID;

--JOIN은 INNER조인, INNER 생략가능함
SELECT C.NAME, SUM(O.SALE_CNT)
FROM TBL_TEST_ORDER O
JOIN TBL_TEST_CUSTOMER C
ON O.ID = C.ID
GROUP BY C.NAME;


--고객별 주문수량의 합계, 주문하지 않은 고객도 함께 조회
--OUTER JOIN

--
SELECT * FROM TBL_TEST_ORDER;
SELECT * FROM TBL_TEST_CUSTOMER;

SELECT *
FROM TBL_TEST_ORDER O
RIGHT OUTER JOIN TBL_TEST_CUSTOMER C
ON O.ID = C.ID;

--
SELECT C.NAME, O.SALE_CNT
FROM TBL_TEST_ORDER O
RIGHT OUTER JOIN TBL_TEST_CUSTOMER C
ON O.ID = C.ID;

--고객별 판매수량의 합계 (주문하지 않은 고객도 포함되도록)
SELECT C.NAME, SUM(O.SALE_CNT)
FROM TBL_TEST_ORDER O
RIGHT OUTER JOIN TBL_TEST_CUSTOMER C
ON O.ID = C.ID
GROUP BY C.NAME;

--NVL()
SELECT C.NAME, NVL(SUM(O.SALE_CNT),0)
FROM TBL_TEST_ORDER O
RIGHT OUTER JOIN TBL_TEST_CUSTOMER C
ON O.ID = C.ID
GROUP BY C.NAME;

--정렬하기
SELECT C.NAME, NVL(SUM(O.SALE_CNT),0) TOTAL_CNT
FROM TBL_TEST_ORDER O
RIGHT OUTER JOIN TBL_TEST_CUSTOMER C
ON O.ID = C.ID
GROUP BY C.NAME
ORDER BY TOTAL_CNT DESC;


--글(테이블)
--댓글(테이블)

--INNER JOIN
--OUTER JOIN

--ON절 조인의 조건이 무엇이냐?
--EQUI JOIN
--NON EQUI JOIN


--P236
--NON EQUI JOIN
SELECT * FROM CUSTOMER;
SELECT * FROM GIFT;

--
--153000
--73000
SELECT * 
FROM CUSTOMER C
JOIN GIFT G
ON C.POINT >= G.G_START AND C.POINT <= G.G_END;
-- ON POINT >= 73000 AND POINT <= 153000

SELECT C.GNAME CUST_NAME, TO_CHAR(C.POINT,'999,999') POINT, G.GNAME GIFT_NAME
FROM CUSTOMER C
JOIN GIFT G
ON C.POINT >= G.G_START AND C.POINT <= G.G_END;


--P239 NON-EQUI조인 문제
--사용 예 2. STUDNET 테이블과 SCORE 테이블, HAKJUM 테이블을 조회하여 학생들의 이름과 점수, 학점을 출력
SELECT * FROM STUDENT;
SELECT * FROM SCORE;
SELECT * FROM HAKJUM;

--이름점수만
SELECT ST.NAME, SC.TOTAL
FROM STUDENT ST
JOIN SCORE SC
ON ST.STUDNO = SC.STUDNO;

--이름점수학점
SELECT ST.NAME, SC.TOTAL, H.GRADE
FROM STUDENT ST
JOIN SCORE SC
ON ST.STUDNO = SC.STUDNO
JOIN HAKJUM H
ON SC.TOTAL >= H.MIN_POINT AND SC.TOTAL <= H.MAX_POINT;


--OUTER조인 연습문제
--P241
--사용 예 1. STUDENT 테이블과 PROFESSOR 테이블을 조인하여 학생이름과 지도교수 이름출력, 지도교수 없는 애들도 출력 헐ㅜ왜없대
SELECT * FROM STUDENT;
SELECT * FROM PROFESSOR;

--학생이름 교수이름
SELECT  S.NAME ,P.NAME
FROM STUDENT S
LEFT OUTER JOIN PROFESSOR P
ON S.PROFNO = P.PROFNO;

--정렬, AS추가, NVL
SELECT  S.NAME STU_NAME ,NVL(P.NAME,' ') PROF_NAME
FROM STUDENT S
LEFT OUTER JOIN PROFESSOR P
ON S.PROFNO = P.PROFNO
ORDER BY P.PROFNO;

--사용 예 2. STUDENT 테이블과 PROFESSOR 테이블을 조인하여 학생이름과 지도교수 이름 출력, 지도학생 없는 교수도 출력
SELECT * FROM STUDENT;
SELECT * FROM PROFESSOR;

--학생이름 교수이름
SELECT S.NAME, P.NAME
FROM STUDENT S
RIGHT OUTER JOIN PROFESSOR P
ON S.PROFNO = P.PROFNO;

--정렬, AS, NVL
SELECT NVL(S.NAME,' ') STU_NAME, P.NAME PROF_NAME
FROM STUDENT S
RIGHT OUTER JOIN PROFESSOR P
ON S.PROFNO = P.PROFNO
ORDER BY S.STUDNO;


-- 교재 239페이지 NON-EQUI조인 문제
-- 사용 예 2 보성
select * from student;
select * from score;
select * from hakjum;
-- 학생 성적 출력
select s.name, o.total
from student S
join score O
on S.studno = O.studno;
-- 등급에 해당하는 최소 값 이상 and 최대 값 이하인 경우의 등급 출력
select s.name as STU_NAME, o.total as SOCRE, h.grade as CREDIT
from student S
join score O
on S.studno = O.studno
join hakjum H
on o.total >= h.min_point and o.total <= h.max_point;

--241페이지 OUTER조인 문제
-- 사용 예1 지태
SELECT
    S.NAME AS STU_NAME,
    NVL(P.NAME, ' ') AS PROF_NAME
FROM 
    STUDENT S
LEFT OUTER JOIN 
    PROFESSOR P
ON S.PROFNO = P.PROFNO;

--사용 예2 연수
SELECT NVL(S.NAME, ' '), P.NAME
FROM STUDENT S
RIGHT OUTER JOIN PROFESSOR P
ON S.PROFNO = P.PROFNO
ORDER BY S.NAME;


--CROSS JOIN
--JOIN의 조건이 없는 조인  --ON절이 없다는건가??????/ 헐맞네; 걍 다 갖다 붙이는건가봐
SELECT * FROM TBL_TEST_ORDER
CROSS JOIN TBL_TEST_CUSTOMER;

-- N*N
-- 5*3 => 15개
-- 10000 * 10000 => 100000000 => 1억


--SELF JOIN (p250)
SELECT * FROM EMP;

SELECT EMPNO, ENAME, MGR    --MGR관리자번호인가>? 아 ㅇㅋ
FROM EMP;

SELECT A.EMPNO, A.ENAME, A.MGR, B.ENAME MGR_NAME
FROM EMP A
JOIN EMP B
ON A.MGR = B.EMPNO;

SELECT *
FROM EMP A
JOIN EMP B
ON A.MGR = B.EMPNO;


--INNER, INNER 생략가능
--OUTER - LEFT OUTER RIGHT OUTER FULL OUTER
--CROSS JOIN
--SELF JOIN



--한양CU 문제풀이 / 문제풀이day5에 적어놧습니덩

--P254 ㅡ연습문제
--1. STUDENT 테이블과 DEPARTMENT 테이블을 사용하여 학생이름, 1전공번호, 1전공이름 출력
SELECT * FROM STUDENT;
SELECT * FROM DEPARTMENT;

--ANSI JOIN 문법
SELECT S.NAME STU_NAME, S.DEPTNO1, D.DNAME DEPT_NAME
FROM STUDENT S
JOIN DEPARTMENT D
ON S.DEPTNO1 = D.DEPTNO
ORDER BY S.STUDNO;

--Oracle JOIN 문법
SELECT S.NAME STU_NAME, S.DEPTNO1, D.DNAME DEPT_NAME
FROM STUDENT S, DEPARTMENT D
WHERE S.DEPTNO1 = D.DEPTNO
ORDER BY S.STUDNO;

--2. EMP2 테이블과 P_GRADE 테이블 조회하여 직급있는 사원의 이름과 직급, 연봉, 해당 직급 연봉의 하한,상한 금액 출력
SELECT * FROM EMP2;
SELECT * FROM P_GRADE;

SELECT E.NAME, E.POSITION, E.PAY, P.S_PAY, P.E_PAY
FROM EMP2 E
JOIN P_GRADE P
ON E.POSITION = P.POSITION;

--AS, 천단위기호
SELECT  E.NAME, E.POSITION, TO_CHAR(E.PAY,'999,999,999') PAY,
        TO_CHAR(P.S_PAY,'999,999,999') "Low PAY", TO_CHAR(P.E_PAY,'999,999,999') "High PAY"
FROM EMP2 E
JOIN P_GRADE P
ON E.POSITION = P.POSITION;


--3. EMP2 테이블과 P_GRADE 테이블 조회하여 사원들의 이름, 나이, 현재 직급, 예상 직급 출력
--예상 직급은 나이로 계산, 나이는 오늘(SYSDATE) 기준으로 TRUNC로 소수점 이하는 지우삼
SELECT * FROM EMP2;
SELECT * FROM P_GRADE;

--나이구하기
SELECT NAME, TO_CHAR(SYSDATE, 'YYYY')-TO_CHAR(BIRTHDAY,'YYYY') AGE
FROM EMP2;

SELECT  E.NAME, TO_CHAR(SYSDATE, 'YYYY')-TO_CHAR(E.BIRTHDAY,'YYYY') AGE,
        NVL(E.POSITION,' ') CURR_POSITION
FROM EMP2 E
ORDER BY E.BIRTHDAY DESC;

--
SELECT E.NAME, TO_CHAR(SYSDATE, 'YYYY')-TO_CHAR(E.BIRTHDAY,'YYYY')AS AGE,
        NVL(E.POSITION,' ') CURR_POSITION, 
        NVL(P.POSITION,'Boss') BE_POSITION --보스는 영원히 보스~
FROM EMP2 E
LEFT JOIN P_GRADE P
ON TO_CHAR(SYSDATE, 'YYYY')-TO_CHAR(E.BIRTHDAY,'YYYY') >= P.S_AGE 
AND TO_CHAR(SYSDATE, 'YYYY')-TO_CHAR(E.BIRTHDAY,'YYYY') <= P.E_AGE
ORDER BY E.BIRTHDAY DESC;

--이거잘안되네염???/
SELECT E.NAME, A.AGE,
        NVL(E.POSITION,' ') CURR_POSITION, 
        NVL(P.POSITION,'Boss') BE_POSITION --보스는 영원히 보스~
FROM (SELECT NAME, TO_CHAR(SYSDATE, 'YYYY')-TO_CHAR(BIRTHDAY,'YYYY') AGE
FROM EMP2 E) A
EMP2 E
LEFT JOIN P_GRADE P
ON A.AGE >= P.S_AGE AND A.AGE <= P.E_AGE;
--ORDER BY E.BIRTHDAY DESC;


--4. CUSTOMER 테이블과 GIFT 테이블 조인하여 고객의 포인트보다 낮은 포인트의 상품 중 하나를 선택할 수 있다고 할 때
-- Notebook을 선택할 수 있는 고객명, 포인트, 상품명 출력
SELECT * FROM CUSTOMER;
SELECT * FROM GIFT;
--그니까 노트북이 600001 포인트부터 가능하잔아 포인트가 600001이상인 사람?

SELECT C.GNAME, C.POINT, G.GNAME
FROM CUSTOMER C
JOIN GIFT G
ON C.POINT >= G_START
WHERE G.GNAME='Notebook'
ORDER BY C.POINT DESC;





