--P254 ㅡ연습문제
--1. STUDENT 테이블과 DEPARTMENT 테이블을 사용하여 학생이름, 1전공번호, 1전공이름 출력
SELECT * FROM STUDENT;
SELECT * FROM DEPARTMENT;

--ANSI JOIN 문법
SELECT S.NAME STU_NAME, S.DEPTNO1, D.DNAME DEPT_NAME
FROM STUDENT S
JOIN DEPARTMENT D
ON S.DEPTNO1 = D.DEPTNO
ORDER BY S.STUDNO;

--Oracle JOIN 문법
SELECT S.NAME STU_NAME, S.DEPTNO1, D.DNAME DEPT_NAME
FROM STUDENT S, DEPARTMENT D
WHERE S.DEPTNO1 = D.DEPTNO
ORDER BY S.STUDNO;

--2. EMP2 테이블과 P_GRADE 테이블 조회하여 직급있는 사원의 이름과 직급, 연봉, 해당 직급 연봉의 하한,상한 금액 출력
SELECT * FROM EMP2;
SELECT * FROM P_GRADE;

SELECT E.NAME, E.POSITION, E.PAY, P.S_PAY, P.E_PAY
FROM EMP2 E
JOIN P_GRADE P
ON E.POSITION = P.POSITION;

--AS, 천단위기호
SELECT  E.NAME, E.POSITION, TO_CHAR(E.PAY,'999,999,999') PAY,
        TO_CHAR(P.S_PAY,'999,999,999') "Low PAY", TO_CHAR(P.E_PAY,'999,999,999') "High PAY"
FROM EMP2 E
JOIN P_GRADE P
ON E.POSITION = P.POSITION;


--3. EMP2 테이블과 P_GRADE 테이블 조회하여 사원들의 이름, 나이, 현재 직급, 예상 직급 출력
--예상 직급은 나이로 계산, 나이는 오늘(SYSDATE) 기준으로 TRUNC로 소수점 이하는 지우삼
SELECT * FROM EMP2;
SELECT * FROM P_GRADE;

--나이구하기
SELECT NAME, TO_CHAR(SYSDATE, 'YYYY')-TO_CHAR(BIRTHDAY,'YYYY') AGE
FROM EMP2;

SELECT  E.NAME, TO_CHAR(SYSDATE, 'YYYY')-TO_CHAR(E.BIRTHDAY,'YYYY') AGE,
        NVL(E.POSITION,' ') CURR_POSITION
FROM EMP2 E
ORDER BY E.BIRTHDAY DESC;

--
SELECT E.NAME, TO_CHAR(SYSDATE, 'YYYY')-TO_CHAR(E.BIRTHDAY,'YYYY')AS AGE,
        NVL(E.POSITION,' ') CURR_POSITION, 
        NVL(P.POSITION,'Boss') BE_POSITION --보스는 영원히 보스~
FROM EMP2 E
LEFT JOIN P_GRADE P
ON TO_CHAR(SYSDATE, 'YYYY')-TO_CHAR(E.BIRTHDAY,'YYYY') >= P.S_AGE 
AND TO_CHAR(SYSDATE, 'YYYY')-TO_CHAR(E.BIRTHDAY,'YYYY') <= P.E_AGE
ORDER BY E.BIRTHDAY DESC;

--나이 책이랑 맞춰서 해볼게여
SELECT E.NAME, TO_CHAR(SYSDATE, 'YYYY')-TO_CHAR(E.BIRTHDAY,'YYYY')-12 AS AGE,
        NVL(E.POSITION,' ') CURR_POSITION, P.POSITION,' ' BE_POSITION
FROM EMP2 E
LEFT JOIN P_GRADE P
ON TO_CHAR(SYSDATE, 'YYYY')-TO_CHAR(E.BIRTHDAY,'YYYY')-12 >= P.S_AGE 
AND TO_CHAR(SYSDATE, 'YYYY')-TO_CHAR(E.BIRTHDAY,'YYYY')-12 <= P.E_AGE
ORDER BY E.BIRTHDAY DESC;




--4. CUSTOMER 테이블과 GIFT 테이블 조인하여 고객의 포인트보다 낮은 포인트의 상품 중 하나를 선택할 수 있다고 할 때
-- Notebook을 선택할 수 있는 고객명, 포인트, 상품명 출력
SELECT * FROM CUSTOMER;
SELECT * FROM GIFT;
--그니까 노트북이 600001 포인트부터 가능하잔아 포인트가 600001이상인 사람?

SELECT C.GNAME, C.POINT, G.GNAME
FROM CUSTOMER C
JOIN GIFT G
ON C.POINT >= G_START
WHERE G.GNAME='Notebook'
ORDER BY C.POINT DESC;





-----------발표~~~
--배드민턴 정호
SELECT * FROM tbl_resv_202301;
SELECT * FROM tbl_cust_202301;

SELECT * 
FROM tbl_cust_202301 C
JOIN tbl_resv_202301 R
ON C.CUST_NO = R.CUST_NO;

SELECT C.CUST_NO, C.CUST_NAME, R.COURT_NO
FROM tbl_cust_202301 C
JOIN tbl_resv_202301 R
ON C.CUST_NO = R.CUST_NO;

SELECT C.CUST_NO "고객번호", C.CUST_NAME "이름", COUNT(R.COURT_NO) "사용일수"
FROM tbl_cust_202301 C
JOIN tbl_resv_202301 R
ON C.CUST_NO = R.CUST_NO
GROUP BY C.CUST_NO, C.CUST_NAME
ORDER BY 1;
SELECT R.RESV_NO "고객번호", 
       C.CUST_NAME "이름", 
       TO_CHAR(TO_DATE(R.RESV_DATE, 'YYYYMMDD'), '""YYYY"년"MM"월"DD"일"') "코트 사용 일자",
       R.COURT_NO "코드번호"
FROM tbl_cust_202301 C
JOIN tbl_resv_202301 R
ON C.CUST_NO = R.CUST_NO
WHERE R.COURT_NO = 'C005';

--연습문제
--1. 민환
--JOIN
SELECT S.NAME "STU_NAME", S.DEPTNO1, D.DNAME "DEPT_NAME"
FROM STUDENT S
JOIN DEPARTMENT D
ON S.DEPTNO1 = D.DEPTNO;

--2. 수경
select * from emp2;
select * from p_grade;

select *
from emp2 e
join p_grade p
on e.position = p.position;


select e.position
from emp2 e
join p_grade p
on e.position = p.position;


select e.name,
       e.position,
       to_char(e.pay,'999,999,999')"PAY",
       to_char(p.s_pay,'999,999,999')"Low PAY",
       to_char(p.e_pay,'999,999,999')"High Pay"
from emp2 e
join p_grade p
on e.position = p.position;

--3. 수민
SELECT * FROM EMP2;
SELECT * FROM p_grade;

SELECT SYSDATE FROM DUAL;

SELECT 
NAME,
ROUND(MONTHS_BETWEEN(SYSDATE, TO_DATE(BIRTHDAY))/12) AGE,
POSITION CURR_POSITION
FROM EMP2;

SELECT E.NAME, E.AGE, E.curr_position, p.position BE_POSITION
FROM (
    SELECT 
    NAME,
    ROUND(MONTHS_BETWEEN(SYSDATE, TO_DATE(BIRTHDAY))/12) AGE,
    POSITION CURR_POSITION
    FROM EMP2) E 
JOIN P_GRADE P
ON E.AGE>=P.S_AGE AND E.AGE<=P.E_AGE
ORDER BY AGE;

SELECT E.NAME, E.AGE, E.curr_position, p.position BE_POSITION
FROM (
    SELECT 
    NAME,
    ROUND(MONTHS_BETWEEN(SYSDATE, TO_DATE(BIRTHDAY))/12-12) AGE,
    POSITION CURR_POSITION
    FROM EMP2) E 
JOIN P_GRADE P
ON E.AGE>=P.S_AGE AND E.AGE<=P.E_AGE
ORDER BY AGE;





